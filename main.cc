// This file contains a complete gtkmm4 C++ application in a single file with an integrated neural network.
// The program is designed for interactive training and classification of gestures, with support for hold detection and exporting trained parameters.
// build: g++ -std=c++20 main.cc `pkg-config --cflags --libs gtkmm-4.0 ` -o app -g
#include <gtkmm.h>
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <deque>
#define _USE_MATH_DEFINES
#include <cmath>
#include <random>
#include <numeric>
#include <map>
#include <chrono>
#include <iomanip>
#include <memory>

// ******************** Pre-trained network parameters ********************
// Generated neural network parameters
std::vector<std::vector<double>> W_in_pretrained = {
    { 3.036988, -1.023292, -0.800672, 9.337006, -4.296382, -4.908416, -1.933761, -0.272010 },    { -5.495846, 13.516294, -3.496437, 2.287122, -3.973014, -4.845650, -3.043515, 6.716483 },    { 3.352057, -3.320778, 0.331671, -0.355259, -2.787049, -0.873708, -5.366481, 0.366557 },    { -2.907626, 3.393606, -0.801842, -1.206386, -2.485075, -0.211124, 1.270831, 2.737673 },    { 5.041726, -1.564233, 0.046658, -2.782507, -0.486636, -0.118111, -1.484062, 5.517083 },    { 0.787113, -3.341954, 4.444616, -1.978481, 2.370716, 3.559562, 2.924140, 0.650072 },    { 4.235905, -2.136201, 3.621924, -2.487270, 0.066946, -1.189528, 3.085602, 1.627013 },    { 1.639400, -3.522374, 4.127647, -1.753721, 3.113015, 1.471038, 1.387873, -0.515148 },    { 4.988148, -3.103933, 0.048083, -0.354210, -0.123164, -2.118746, 3.924333, -2.729468 },    { 1.049000, 0.464219, -1.539282, -1.490961, 0.387228, -0.084482, 2.584178, -3.529735 },    { 3.895587, -2.513065, -1.664663, -0.119063, -2.170808, 0.805220, -2.299982, -5.500890 },    { 0.621916, 5.256309, -4.150643, -0.837818, -0.294525, 0.134172, 6.041821, -3.171903 },    { 2.008658, 2.884546, 1.073162, -1.535734, -1.870566, 4.266515, -6.394345, -6.150350 },    { 2.476479, 6.034343, -4.257177, 1.411338, 1.428793, 1.301941, 6.792211, -1.928699 },    { 0.207529, -0.012530, 2.783034, -0.532478, -2.060442, 4.525191, -5.838743, -1.060552 },    { 1.737261, 1.031679, -2.778145, 2.226843, 1.690813, 1.623209, 4.825877, -0.136955 },    { -1.069235, -0.050500, 1.902386, 0.612084, -2.810726, 3.782766, -1.056001, 1.745284 },    { -0.752529, -3.489316, -0.552228, 1.564607, 0.985775, 1.376620, 1.810786, 1.523200 },    { -0.043019, -2.275579, -2.171947, 1.241804, -1.140076, 1.195225, 1.979053, 5.790789 },    { -3.290356, -2.242951, 1.904938, 0.388371, 4.118867, 0.354661, -1.182555, 1.673891 },    { -0.107182, -1.407109, -4.983886, -0.246348, 2.040394, -2.154434, 2.999095, 3.549031 },    { -4.330365, -1.607570, 3.808367, 0.136078, 3.774625, 0.038928, -2.452322, 0.256130 },    { -0.642727, -0.395856, -6.412294, -0.831653, 3.154724, -3.103579, 3.734275, 3.056979 },    { -3.944029, -0.896478, 3.119510, 0.062893, 4.003982, 0.890463, -2.271028, -1.286749 },};
std::vector<double> B_hidden_pretrained = { -0.798534, -2.539520, 2.703064, 0.303937, 0.166963, -1.596155, -0.860674, -0.804563 };
std::vector<std::vector<double>> W_out_pretrained = {
    { -5.352964, -9.024419, 1.999720, 1.982381, -5.905503, 1.015754, -8.317823, -8.214466, 0.508730, 1.780074, 4.377962, 3.247978, 4.013508, 1.858773, 6.381685, -7.583852, -8.433141, 0.373913, -5.731104, 2.540619, -6.178806, 2.786457, 1.659002, -9.028364, -5.895134, -1.134588 },    { -2.847807, 1.936590, -4.376050, -2.833707, -9.587351, 3.784358, -4.820323, -6.938610, -4.994061, 5.058781, -8.529112, -4.553072, 4.394176, -0.640162, 6.556827, 3.571923, -6.923788, -4.805173, 2.986206, 8.036304, 5.965519, -7.313988, -8.486309, 7.008681, -3.533809, 1.971733 },    { 0.438957, 5.816215, 6.014569, -7.467918, 1.403465, -5.971593, 0.021839, -11.085553, 0.659725, 3.509777, -9.581272, -2.538381, 0.525479, 6.978199, -6.043225, -10.274391, -3.852303, 3.854675, -5.218247, -9.998015, -2.539398, -7.893994, 1.933925, 5.333587, 5.063708, -6.162353 },    { 2.494042, -6.790023, -0.016502, -5.356809, 3.350770, -4.733815, -8.563699, 1.759771, 2.357292, -9.091457, 6.870853, -7.959404, -1.656311, -6.071245, 1.227246, -1.657585, 4.073790, -4.585168, -6.396064, -9.687616, 0.320460, -4.920841, -7.167236, 5.066086, 1.301904, 5.054535 },    { 3.795789, -4.096622, -3.220250, -2.440517, -6.081066, 5.305191, 0.606774, 0.336364, -3.857471, -7.201872, -5.782594, -0.259260, -3.879812, -8.211941, -5.367991, -9.205669, -0.759244, 6.151583, 6.838890, -7.333418, 9.472655, 5.746255, -1.424400, -5.163654, 2.857124, -5.397383 },    { 0.990916, -5.807976, -6.347187, 3.318325, 6.424697, -0.728711, 3.112952, 3.344990, -5.844214, -4.164506, -4.398310, -7.993201, 2.645844, 3.599237, -9.033149, -0.733691, -6.817245, -0.757677, -5.149246, 1.026701, 5.380126, 4.788637, 2.914336, -1.144862, -8.907627, 4.224776 },    { -0.024319, 2.745711, -8.264491, -7.114475, -6.555867, 0.612234, 4.521678, 6.261882, 7.022973, 2.214709, -0.780306, 2.261370, -11.103715, 0.065398, 1.723531, -2.691138, -4.961456, -8.462288, 0.929135, 0.834111, -8.935684, 2.231810, 2.326368, -5.494835, 3.738425, 2.117543 },    { -8.286080, 0.664256, -1.468139, 0.913174, -2.076128, -9.611626, 0.199013, -0.892370, -7.905185, -8.857938, 0.630363, 1.210137, -7.064130, 6.712851, -1.546037, 3.765178, 1.671053, -0.106099, -1.125644, 3.181063, -3.753455, -0.149577, -6.408316, -2.622246, -0.259199, -6.358599 },};
std::vector<double> B_out_pretrained = { -3.249445, -3.740525, -3.475216, -0.518497, -3.043611, -3.464331, -4.321433, -4.933420, -4.470646, -3.622989, -6.624032, -2.114828, -4.483371, -14.664073, -10.629263, 0.683667, -0.296716, -5.148587, -2.795929, -9.663978, -8.706391, -11.105847, -3.648800, -10.378188, -8.198466, -7.023166 };
// *************************************************************************

struct Point {
    double x, y;
};

struct Gesture {
    std::string name;
    std::vector<Point> points;
};

const std::vector<Gesture> g_gestureData = {

    {"Up", {{-63.7109, -222.332},{-63.7109, -220.68},{-62.0625, -210.773},{-60.4102, -189.312},{-60.4102, -156.289},{-57.1094, -106.758},{-53.8047, -52.2734},{-50.5039, 3.86328},{-45.5508, 48.4414},{-42.25, 88.0664},{-42.25, 126.043},{-42.25, 154.109},{-42.25, 177.223},{-43.8984, 195.387},{-43.8984, 208.594},{-43.8984, 213.547},{-43.8984, 213.547},{-43.8984, 213.547}        }},
    {"Down", { {-55.457, 220.152},{-55.457, 218.5},{-55.457, 211.898},{-55.457, 193.734},{-58.7578, 172.27},{-62.0625, 137.598},{-68.6641, 94.6719},{-81.875, 46.7891},{-100.035, -1.08984},{-116.547, -45.668},{-128.105, -90.2461},{-139.66, -123.27},{-149.566, -146.383},{-157.824, -162.895},{-159.473, -166.195},{-159.473, -167.848},{-159.473, -167.848},{-159.473, -167.848},        }},
    {"Left", { {144.32, -1.09375},{141.02, -1.09375},{91.4883, 12.1172},{0.679688, 25.3242},{-81.875, 35.2305},{-156.172, 41.8359},{-228.82, 50.0898},{-291.559, 58.3477},{-344.395, 63.3008},{-379.066, 66.6016},{-397.227, 68.2539},{-400.527, 68.2539},{-400.527, 68.2539},{-400.527, 68.2539},        }},
    {"Right", { {-316.324, -75.3906},{-314.676, -75.3906},{-294.859, -75.3906},{-258.539, -77.043},{-185.891, -75.3906},{-103.34, -68.7852},{-14.1797, -57.2266},{73.3242, -47.3203},{139.367, -42.3672},{192.203, -42.3672},{225.223, -40.7188},{238.434, -40.7188},{238.434, -40.7188},{238.434, -40.7188},        }},
    {"Circle", { {-152.871, 63.3008},{-157.824, 63.3008},{-174.336, 63.3008},{-192.496, 63.3008},{-217.262, 59.9961},{-240.375, 51.7422},{-263.492, 40.1836},{-271.746, 31.9297},{-281.652, 18.7188},{-284.957, 8.8125},{-286.605, -7.69531},{-283.305, -22.5547},{-275.051, -37.4141},{-268.445, -47.3203},{-235.422, -77.043},{-190.844, -103.457},{-126.453, -116.668},{-96.7344, -118.316},{-78.5742, -113.363},{-60.4102, -105.109},{-45.5508, -96.8555},{-37.2969, -86.9492},{-33.9922, -75.3906},{-32.3438, -60.5312},{-32.3438, -47.3203},{-38.9453, -29.1602},{-45.5508, -11},{-53.8047, 3.85938},{-63.7148, 17.0703},{-71.9688, 26.9766},{-81.875, 35.2305},{-91.7812, 41.8359},{-103.34, 50.0898},{-109.941, 55.043},{-118.199, 58.3477},{-121.5, 59.9961},{-121.5, 59.9961},{-123.152, 59.9961},{-123.152, 61.6484},{-123.152, 61.6484},        }},
    {"Char: 1", { {-121.5, -80.3438},{-100.035, -57.2266},{-67.0156, -19.2539},{-22.4375, 26.9766},{23.793, 73.207},{60.1172, 109.527},{88.1836, 142.551},{104.695, 164.016},{109.648, 172.27},{111.301, 173.922},{111.301, 173.922},{111.301, 172.27},{111.301, 170.617},{106.348, 157.41},{99.7422, 140.898},{86.5352, 104.574},{65.0703, 46.7891},{48.5586, 2.21094},{27.0938, -57.2305},{2.32812, -115.016},{-22.4375, -161.246},{-40.5977, -197.57},{-48.8516, -215.73},{-50.5039, -222.336},{-50.5039, -222.336},{-50.5039, -222.336},        }},
    {"Char: N", { {-182.59, -212.43},{-182.59, -207.477},{-180.938, -190.965},{-179.289, -161.246},{-175.984, -118.32},{-166.078, -63.832},{-154.52, -7.69922},{-144.613, 36.8828},{-136.359, 73.2031},{-133.059, 99.6211},{-133.059, 119.434},{-133.059, 121.086},{-131.406, 121.086},{-131.406, 121.086},{-131.406, 119.434},{-128.105, 112.828},{-121.5, 97.9688},{-111.594, 68.25},{-98.3867, 22.0195},{-85.1758, -34.1133},{-70.3164, -93.5547},{-58.7578, -144.734},{-52.1562, -176.105},{-48.8516, -197.57},{-45.5508, -212.43},{-42.25, -220.684},{-42.25, -222.336},{-42.25, -222.336},{-40.5977, -222.336},{-40.5977, -222.336},{-37.2969, -215.73},{-27.3906, -192.617},{-12.5312, -162.898},{7.28125, -124.922},{33.6992, -73.7422},{56.8164, -24.207},{78.2773, 22.0195},{98.0898, 66.6016},{104.695, 86.4141},{106.348, 91.3672},{106.348, 91.3672},{104.695, 89.7149},{103.043, 89.7149},{103.043, 89.7149},        }},
    {"Char: J", { {-109.941, -27.5117},{-104.988, -35.7656},{-98.3867, -55.5781},{-90.1289, -85.2969},{-80.2227, -121.621},{-68.668, -156.293},{-57.1094, -174.457},{-53.8047, -177.758},{-50.5039, -177.758},{-40.5977, -167.852},{-22.4375, -143.086},{3.98047, -108.414},{43.6055, -62.1836},{93.1367, -11},{145.973, 36.8789},{195.504, 81.461},{233.477, 111.18},{258.246, 134.293},{263.199, 142.547},{263.199, 142.547},{263.199, 140.898},{263.199, 140.898},{261.547, 139.246},{259.895, 139.246},{259.895, 139.246},        }    },
    {"Char: ^", { {25.4414, 30.2773},{25.4414, 31.9297},{17.1875, 74.8555},{7.28125, 106.227},{-5.92578, 139.246},{-24.0898, 172.27},{-47.2031, 195.383},{-76.9219, 215.195},{-103.34, 221.801},{-126.453, 220.148},{-146.266, 208.594},{-166.082, 193.73},{-182.59, 178.871},{-197.449, 164.012},{-212.309, 147.504},{-225.52, 132.645},{-230.473, 121.086},{-230.473, 119.434},{-230.473, 119.434},{-230.473, 119.434},        }    },
    {"Char: >", { {-95.0859, 190.43},{-93.4336, 190.43},{-70.3203, 167.316},{-38.9492, 144.199},{2.32812, 109.527},{45.2539, 74.8555},{86.5312, 45.1367},{122.855, 17.0703},{155.875, -4.39453},{170.738, -17.6055},{177.34, -24.207},{178.992, -25.8594},{178.992, -25.8594},{177.34, -27.5117},{169.086, -29.1602},{154.227, -35.7656},{119.555, -50.625},{78.2773, -72.0898},{41.9531, -91.9023},{-15.832, -119.969},{-48.8555, -133.18},{-81.875, -146.387},{-101.688, -157.945},{-106.641, -162.898},{-106.641, -162.898},{-106.641, -162.898},        }    },
    {"Char: <", { {109.648, 84.7617},{107.996, 86.4141},{96.4375, 91.3672},{63.418, 99.6211},{25.4414, 107.879},{-29.043, 114.48},{-98.3867, 119.434},{-171.031, 124.387},{-242.027, 127.691},{-301.469, 124.387},{-322.93, 116.133},{-332.836, 107.879},{-334.488, 101.273},{-332.836, 88.0664},{-327.883, 78.1602},{-317.977, 64.9492},{-299.816, 51.7422},{-270.098, 38.5312},{-228.82, 25.3242},{-177.637, 13.7656},{-118.199, 7.16406},{-76.9219, 5.51172},{-40.5977, 3.85938},{-17.4844, 3.85938},{-5.92578, 3.85938},{-5.92578, 3.85938},{-4.27734, 3.85938},{-2.625, 3.85938},{7.28125, 0.558594},{10.582, -1.09375},{10.582, -1.09375},        }    },
    {"Char: Z", { {-210.66, 173.922},{-202.402, 173.922},{-136.359, 172.27},{-55.457, 164.012},{43.6055, 154.105},{137.715, 142.551},{216.965, 132.645},{268.148, 124.387},{286.312, 121.086},{286.312, 121.086},{286.312, 119.434},{278.055, 112.832},{254.941, 101.273},{216.965, 81.461},{160.832, 56.6953},{93.1367, 25.3242},{20.4883, -9.34766},{-48.8555, -42.3711},{-119.852, -73.7383},{-192.496, -95.2031},{-225.52, -106.762},{-235.426, -111.715},{-235.426, -111.715},{-235.426, -113.363},{-227.168, -116.668},{-205.707, -121.621},{-171.031, -124.922},{-121.5, -124.922},{-58.7617, -124.922},{8.93359, -126.574},{83.2305, -126.574},{127.809, -126.574},{152.574, -126.574},{162.48, -126.574},{162.48, -126.574},{162.48, -126.574},        }    },
    {"Char: S", { {190.551, 99.6211},{180.645, 102.926},{144.32, 112.832},{83.2305, 124.387},{23.793, 130.992},{-38.9492, 134.293},{-91.7812, 134.293},{-126.453, 129.34},{-142.965, 121.086},{-147.918, 111.18},{-144.617, 93.0195},{-129.758, 66.6016},{-106.641, 40.1836},{-70.3203, 20.3711},{-30.6914, 7.16406},{18.8398, -6.04688},{58.4648, -17.6016},{81.5781, -27.5078},{98.0898, -35.7656},{107.996, -45.6719},{114.602, -60.5312},{116.25, -78.6914},{112.949, -100.156},{99.7422, -116.668},{71.6719, -134.828},{35.3477, -149.687},{-4.27734, -161.246},{-38.9492, -167.852},{-73.6211, -171.152},{-103.34, -171.152},{-124.805, -167.852},{-147.918, -161.246},{-174.336, -152.992},{-192.496, -148.039},{-207.355, -141.434},{-215.613, -139.781},{-217.262, -139.781},{-217.262, -139.781},{-217.262, -139.781},        }    },
    {"Char: 3", { {-162.777, 152.457},{-162.777, 154.105},{-154.523, 164.012},{-134.711, 173.922},{-93.4336, 180.523},{-35.6445, 183.828},{22.1406, 185.477},{68.3711, 183.828},{98.0898, 173.922},{112.949, 165.664},{116.25, 157.41},{117.902, 144.199},{109.648, 126.039},{94.7891, 106.227},{61.7656, 83.1133},{12.2344, 59.9961},{-48.8555, 43.4844},{-104.992, 33.5781},{-151.219, 33.5781},{-174.336, 36.8828},{-177.637, 36.8828},{-177.637, 36.8828},{-175.988, 36.8828},{-175.988, 36.8828},{-167.73, 33.5781},{-146.266, 30.2773},{-109.945, 25.3242},{-63.7148, 18.7188},{-25.7383, 8.8125},{3.98047, -2.74219},{18.8398, -12.6484},{22.1406, -19.2539},{22.1406, -29.1602},{22.1406, -39.0664},{15.5352, -55.5781},{0.675781, -75.3906},{-17.4844, -96.8555},{-40.5977, -116.668},{-73.6211, -131.527},{-101.688, -138.129},{-126.453, -139.781},{-142.965, -138.129},{-156.176, -133.176},{-171.035, -128.223},{-185.895, -124.922},{-192.496, -124.922},{-195.801, -124.922},{-197.449, -124.922},{-197.449, -124.922},{-197.449, -124.922},        }    },
    {"Char: E", { {106.344, 117.785},{99.7422, 119.434},{63.418, 132.645},{23.793, 139.246},{-25.7383, 145.852},{-85.1797, 147.504},{-142.965, 145.852},{-187.543, 134.293},{-220.566, 119.434},{-232.121, 106.227},{-228.82, 89.7149},{-212.309, 73.207},{-180.941, 56.6953},{-142.965, 48.4375},{-100.039, 41.8359},{-58.7617, 40.1836},{-27.3906, 40.1836},{-12.5312, 40.1836},{-10.8789, 40.1836},{-10.8789, 40.1836},{-15.832, 40.1836},{-33.9961, 35.2305},{-55.4609, 30.2773},{-100.039, 20.3711},{-133.059, 13.7656},{-175.988, 2.21094},{-202.402, -7.69531},{-220.566, -17.6016},{-228.82, -24.207},{-230.473, -32.4609},{-225.52, -42.3711},{-217.262, -55.5781},{-202.402, -68.7852},{-180.941, -81.9961},{-152.871, -93.5508},{-126.453, -100.156},{-101.688, -103.457},{-78.5742, -103.457},{-67.0156, -103.457},{-60.4141, -103.457},{-53.8086, -103.457},{-45.5508, -103.457},{-35.6445, -105.109},{-29.043, -105.109},{-19.1367, -105.109},{-14.1836, -105.109},{-12.5312, -105.109},{-12.5312, -105.109},        }    },
    {"Char: L", { {-167.73, 97.9727},{-169.383, 93.0195},{-184.242, 53.3906},{-194.148, 15.418},{-202.402, -30.8125},{-209.008, -75.3906},{-218.914, -111.715},{-225.52, -139.781},{-228.82, -159.594},{-228.82, -166.199},{-228.82, -166.199},{-227.168, -167.852},{-225.52, -167.852},{-200.754, -171.152},{-162.777, -171.152},{-116.547, -169.5},{-71.9688, -164.547},{-12.5312, -162.898},{38.6523, -162.898},{63.418, -159.594},{66.7188, -157.945},{66.7188, -157.945},{66.7188, -157.945},        }    },
    {"Char: V", { {-78.5742, -20.9062},{-78.5742, -22.5547},{-81.875, -30.8125},{-88.4805, -44.0195},{-96.7344, -62.1836},{-108.293, -83.6445},{-126.453, -115.016},{-147.918, -149.687},{-166.082, -179.406},{-177.637, -204.172},{-180.941, -219.031},{-180.941, -225.637},{-180.941, -228.938},{-180.941, -228.938},{-179.289, -228.938},{-177.637, -228.938},{-175.988, -228.938},{-175.988, -228.938},{-174.336, -228.938},{-169.383, -227.289},{-159.477, -223.984},{-133.059, -209.125},{-100.039, -189.312},{-53.8086, -157.945},{-14.1836, -126.574},{15.5352, -98.5039},{38.6523, -78.6914},{51.8594, -63.832},{56.8125, -60.5312},{58.4648, -60.5312},{58.4648, -60.5312},{58.4648, -60.5312},        }    },
    {"Char: b", { {-273.398, -48.9727},{-266.797, -47.3242},{-248.633, -44.0195},{-200.754, -34.1133},{-149.57, -25.8594},{-100.039, -22.5547},{-63.7148, -20.9062},{-40.5977, -25.8594},{-22.4375, -37.418},{-7.57812, -55.5781},{3.98047, -75.3906},{15.5352, -98.5039},{20.4883, -123.27},{20.4883, -146.387},{13.8867, -162.898},{-0.972656, -171.152},{-20.7852, -179.406},{-47.2031, -184.359},{-73.6211, -187.664},{-93.4336, -187.664},{-101.688, -182.711},{-109.945, -171.152},{-119.852, -146.387},{-128.105, -118.316},{-133.059, -81.9961},{-133.059, -45.6719},{-129.758, -6.04688},{-121.5, 31.9297},{-111.594, 61.6484},{-103.34, 84.7617},{-96.7344, 97.9727},{-95.0859, 99.6211},{-95.0859, 99.6211},{-95.0859, 97.9727},{-95.0859, 97.9727},{-96.7344, 96.3203},{-96.7344, 96.3203},        }    },
    {"Char: W", { {-227.168, 114.48},{-225.52, 114.48},{-220.566, 102.926},{-210.66, 76.5078},{-199.102, 41.8359},{-182.59, -4.39453},{-166.082, -55.5781},{-156.176, -106.762},{-151.219, -151.34},{-149.57, -186.012},{-149.57, -199.219},{-149.57, -200.871},{-147.918, -200.871},{-139.664, -184.359},{-123.152, -152.992},{-108.293, -123.27},{-81.875, -81.9961},{-60.4141, -47.3242},{-38.9492, -9.34766},{-22.4375, 18.7188},{-10.8789, 36.8828},{-7.57812, 40.1836},{-7.57812, 40.1836},{-7.57812, 38.5312},{-7.57812, 31.9297},{-7.57812, 15.418},{-7.57812, -12.6484},{-5.92578, -45.6719},{-5.92578, -85.2969},{-2.625, -116.668},{2.32812, -131.527},{3.98047, -133.18},{3.98047, -133.18},{5.62891, -133.18},{12.2344, -129.875},{23.793, -113.363},{46.9062, -85.2969},{78.2773, -47.3242},{107.996, -6.04688},{139.367, 40.1836},{169.086, 86.4141},{190.551, 117.785},{202.105, 132.645},{205.41, 137.598},{205.41, 137.598},{205.41, 135.945},{205.41, 135.945},        }    },
    {"Char: T", { {-246.98, 145.852},{-243.68, 145.852},{-218.914, 150.805},{-189.195, 152.457},{-141.312, 155.758},{-93.4336, 155.758},{-55.457, 157.41},{-33.9961, 157.41},{-25.7383, 157.41},{-25.7383, 155.758},{-25.7383, 154.105},{-24.0898, 149.152},{-24.0898, 144.199},{-24.0898, 135.945},{-25.7383, 124.387},{-33.9961, 104.574},{-43.9023, 76.5078},{-55.457, 41.8359},{-68.668, -1.09375},{-80.2266, -47.3242},{-88.4805, -91.9023},{-98.3867, -136.48},{-106.641, -177.758},{-111.594, -204.176},{-113.246, -217.383},{-113.246, -217.383},{-111.594, -217.383},{-111.594, -217.383},{-111.594, -217.383},        }    },
    {"Char: U", { {-141.312, 51.7422},{-142.965, 41.832},{-151.219, 18.7188},{-157.824, -9.34766},{-166.082, -42.3711},{-172.684, -86.9492},{-175.988, -133.18},{-175.988, -174.457},{-166.082, -214.082},{-157.824, -228.941},{-146.266, -238.848},{-136.359, -238.848},{-129.758, -238.848},{-116.547, -233.895},{-100.039, -225.637},{-83.5273, -215.73},{-67.0156, -202.523},{-47.2031, -187.664},{-29.043, -164.547},{-14.1836, -141.434},{2.32812, -105.109},{8.93359, -75.3906},{10.582, -55.5781},{10.582, -34.1133},{10.582, -17.6055},{12.2344, -6.04688},{12.2344, 3.85938},{12.2344, 12.1133},{12.2344, 18.7188},{13.8867, 20.3711},{13.8867, 22.0195},{13.8867, 22.0195},{13.8867, 22.0195},        }    },
    {"Char: M", { {-218.914, -187.664},{-217.262, -184.363},{-205.707, -151.34},{-194.148, -118.32},{-175.988, -68.7891},{-162.777, -25.8594},{-154.523, 12.1133},{-149.57, 43.4844},{-149.57, 64.9492},{-149.57, 74.8555},{-149.57, 76.5078},{-149.57, 76.5078},{-149.57, 74.8555},{-147.918, 73.2031},{-144.617, 68.25},{-142.965, 63.2969},{-139.664, 56.6914},{-134.711, 50.0898},{-129.758, 40.1836},{-121.5, 25.3242},{-109.945, 3.85938},{-91.7812, -30.8125},{-76.9219, -62.1836},{-65.3672, -88.6016},{-62.0625, -95.2031},{-60.4141, -96.8555},{-60.4141, -96.8555},{-60.4141, -95.2031},{-58.7617, -93.5547},{-45.5508, -70.4375},{-33.9961, -53.9297},{-17.4844, -34.1133},{-0.972656, -12.6523},{20.4883, 15.418},{32.0469, 31.9258},{38.6523, 41.832},{40.3008, 43.4844},{40.3008, 43.4844},{41.9531, 43.4844},{41.9531, 41.832},{43.6055, 35.2305},{46.9062, 22.0195},{51.8594, -1.09375},{56.8125, -25.8594},{60.1172, -75.3906},{61.7656, -119.969},{65.0703, -156.293},{68.3711, -167.852},{68.3711, -169.504},{68.3711, -169.504},{68.3711, -169.504},        }    },
    {"Char: B", { {-184.242, -261.961},{-182.59, -257.008},{-167.73, -228.941},{-151.219, -199.223},{-124.805, -149.691},{-101.688, -110.062},{-67.0156, -50.625},{-35.6445, 3.85938},{-7.57812, 48.4375},{20.4883, 83.1094},{41.9531, 104.574},{60.1172, 116.133},{74.9766, 121.086},{84.8828, 121.086},{91.4844, 121.086},{99.7422, 116.133},{116.25, 106.227},{141.016, 93.0156},{160.832, 81.461},{175.691, 71.5508},{185.598, 58.3438},{192.199, 41.832},{193.852, 26.9727},{192.199, 10.4648},{182.293, -6.04688},{170.738, -17.6055},{150.922, -29.1602},{127.809, -37.418},{111.297, -40.7188},{103.043, -44.0234},{101.391, -44.0234},{101.391, -44.0234},{103.043, -44.0234},{103.043, -44.0234},{112.949, -45.6719},{119.555, -45.6719},{127.809, -47.3242},{134.414, -52.2773},{142.668, -58.8828},{152.574, -70.4375},{159.18, -81.9961},{167.434, -91.9023},{170.738, -101.809},{172.387, -111.715},{172.387, -119.969},{169.086, -128.227},{165.785, -134.828},{159.18, -138.133},{145.969, -143.086},{124.508, -146.387},{96.4375, -154.645},{71.6719, -159.598},{58.4648, -161.246},{53.5117, -161.246},{50.2109, -161.246},{50.2109, -161.246},{48.5586, -161.246},{48.5586, -161.246},{48.5586, -161.246},        }    },
    {"Char: 6", { {70.0234, 150.805},{61.7656, 150.805},{-17.4844, 144.199},{-65.3672, 134.293},{-147.918, 104.574},{-195.801, 71.5547},{-217.262, 45.1367},{-232.121, -4.39453},{-227.168, -44.0195},{-212.309, -80.3438},{-199.102, -108.414},{-180.941, -136.48},{-159.477, -159.594},{-100.039, -199.223},{-53.8086, -210.777},{-0.972656, -212.43},{50.2109, -197.57},{89.8359, -177.758},{117.902, -157.945},{136.062, -141.434},{144.32, -124.922},{147.621, -106.762},{145.969, -90.25},{139.367, -75.3906},{126.156, -60.5312},{107.996, -45.6719},{81.5781, -29.1602},{41.9531, -15.9531},{-9.23047, -6.04688},{-57.1094, -4.39453},{-85.1797, -7.69922},{-98.3867, -11},{-100.039, -11},{-100.039, -11},{-100.039, -12.6523},{-100.039, -12.6523},{-100.039, -12.6523},        }    },
    {"Char: 8", { {46.9062, 230.055},{41.9531, 231.707},{25.4414, 238.309},{-5.92578, 244.914},{-45.5508, 249.867},{-81.875, 249.867},{-111.594, 244.914},{-141.312, 233.355},{-162.777, 213.543},{-179.289, 183.824},{-184.242, 154.105},{-179.289, 124.387},{-159.477, 96.3203},{-121.5, 69.9023},{-71.9688, 48.4375},{-17.4844, 33.5781},{28.7461, 22.0195},{63.418, 12.1133},{86.5312, 5.51172},{101.391, -4.39453},{107.996, -12.6523},{112.949, -27.5117},{116.25, -47.3242},{114.602, -75.3906},{101.391, -105.109},{74.9766, -138.133},{48.5586, -162.898},{23.793, -176.105},{8.93359, -182.711},{0.675781, -182.711},{-5.92578, -182.711},{-17.4844, -179.41},{-37.2969, -171.152},{-70.3203, -156.293},{-109.945, -136.48},{-147.918, -115.016},{-180.941, -95.2031},{-194.148, -85.2969},{-195.801, -75.3906},{-192.496, -60.5312},{-177.637, -35.7656},{-149.57, -6.04688},{-114.898, 23.6719},{-73.6211, 55.043},{-38.9492, 83.1094},{-9.23047, 109.527},{12.2344, 132.641},{23.793, 150.805},{30.3945, 164.012},{32.0469, 173.918},{32.0469, 178.871},{32.0469, 180.523},{30.3945, 182.176},{27.0938, 183.824},{23.793, 185.477},{22.1406, 188.777},{22.1406, 188.777},{22.1406, 188.777},        }    },
    {"Char: 9", { {112.949, 201.988},{104.695, 205.289},{70.0234, 216.848},{25.4414, 228.402},{-27.3906, 238.309},{-78.5742, 243.262},{-126.453, 241.613},{-166.082, 228.402},{-205.707, 203.637},{-227.168, 177.223},{-238.727, 142.547},{-240.379, 112.828},{-232.121, 83.1094},{-217.262, 59.9961},{-194.148, 41.832},{-161.125, 28.625},{-109.945, 17.0664},{-67.0156, 13.7656},{-20.7852, 13.7656},{22.1406, 22.0195},{55.1641, 35.2305},{83.2305, 50.0898},{99.7422, 66.6016},{107.996, 81.461},{111.297, 97.9688},{114.602, 116.133},{116.25, 142.547},{116.25, 165.664},{116.25, 190.43},{111.297, 210.242},{106.344, 221.801},{104.695, 225.102},{104.695, 225.102},{103.043, 225.102},{103.043, 221.801},{103.043, 218.496},{104.695, 208.59},{112.949, 192.082},{124.508, 157.41},{136.062, 117.781},{147.621, 66.6016},{155.879, 17.0664},{162.48, -30.8125},{162.48, -68.7891},{142.668, -106.762},{112.949, -129.875},{73.3242, -154.641},{27.0938, -179.41},{-27.3906, -199.223},{-78.5742, -207.477},{-131.406, -209.129},{-171.035, -195.918},{-187.543, -177.758},{-199.102, -148.039},{-207.355, -118.32},{-213.961, -98.5078},{-218.914, -86.9492},{-222.215, -78.6953},{-225.52, -73.7422},{-225.52, -70.4375},{-227.168, -70.4375},{-228.82, -68.7891},{-230.473, -68.7891},{-230.473, -68.7891},        }    }
};

// Sigmoid activation function
double sigmoid(double x) {
    return 1.0 / (1.0 + exp(-x));
}

// Derivative of the sigmoid function
double sigmoid_derivative(double x) {
    return x * (1.0 - x);
}

// Function for learning rate decay
double learning_rate_scheduler(double initial_lr, int epoch, int decay_interval = 500, double decay_rate = 0.5) {
    return initial_lr * std::pow(decay_rate, floor((double)epoch / decay_interval));
}

// Structure for storing line points with double coordinates
struct Point2D {
    double x;
    double y;
};

// The NeuralNetwork class for handling training and classification.
class NeuralNetwork {
public:
    // Original constructor for random initialization (for training)
    NeuralNetwork(int input, int hidden, int output)
        : input_nodes(input), hidden_nodes(hidden), output_nodes(output) {

        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> distrib(-0.1, 0.1);

        W_in.resize(input_nodes, std::vector<double>(hidden_nodes));
        B_hidden.resize(hidden_nodes);
        W_out.resize(hidden_nodes, std::vector<double>(output_nodes));
        B_out.resize(output_nodes);

        for (int i = 0; i < input_nodes; ++i) {
            for (int j = 0; j < hidden_nodes; ++j) {
                W_in[i][j] = distrib(gen);
            }
        }
        for (int i = 0; i < hidden_nodes; ++i) {
            B_hidden[i] = distrib(gen);
        }
        for (int i = 0; i < hidden_nodes; ++i) {
            for (int j = 0; j < output_nodes; ++j) {
                W_out[i][j] = distrib(gen);
            }
        }
        for (int i = 0; i < output_nodes; ++i) {
            B_out[i] = distrib(gen);
        }
    }

    // Constructor for using pre-trained parameters
    NeuralNetwork(int input, int hidden, int output,
                  const std::vector<std::vector<double>>& W_in_pre,
                  const std::vector<double>& B_hidden_pre,
                  const std::vector<std::vector<double>>& W_out_pre,
                  const std::vector<double>& B_out_pre)
        : input_nodes(input), hidden_nodes(hidden), output_nodes(output),
          W_in(W_in_pre), B_hidden(B_hidden_pre), W_out(W_out_pre), B_out(B_out_pre) {}

    void train(const std::vector<std::vector<double>>& train_inputs,
               const std::vector<std::vector<double>>& target_outputs,
               double initial_learning_rate, int num_epochs) {

        double learning_rate = initial_learning_rate;

        for (int epoch = 1; epoch <= num_epochs; ++epoch) {
            double total_loss = 0.0;
            learning_rate = learning_rate_scheduler(initial_learning_rate, epoch);

            for (size_t i = 0; i < train_inputs.size(); ++i) {
                // Forward propagation
                std::vector<double> hidden_input(hidden_nodes, 0.0);
                for (int j = 0; j < hidden_nodes; ++j) {
                    for (int k = 0; k < input_nodes; ++k) {
                        hidden_input[j] += train_inputs[i][k] * W_in[k][j];
                    }
                    hidden_input[j] += B_hidden[j];
                }
                std::vector<double> hidden_output(hidden_nodes);
                for (int j = 0; j < hidden_nodes; ++j) {
                    hidden_output[j] = sigmoid(hidden_input[j]);
                }

                std::vector<double> output_input(output_nodes, 0.0);
                for (int j = 0; j < output_nodes; ++j) {
                    for (int k = 0; k < hidden_nodes; ++k) {
                        output_input[j] += hidden_output[k] * W_out[k][j];
                    }
                    output_input[j] += B_out[j];
                }
                std::vector<double> final_output(output_nodes);
                for (int j = 0; j < output_nodes; ++j) {
                    final_output[j] = sigmoid(output_input[j]);
                }

                // Error calculation
                double loss = 0.0;
                for (int j = 0; j < output_nodes; ++j) {
                    loss += 0.5 * std::pow(target_outputs[i][j] - final_output[j], 2);
                }
                total_loss += loss;

                // Backward propagation
                std::vector<double> output_delta(output_nodes);
                for (int j = 0; j < output_nodes; ++j) {
                    double error = target_outputs[i][j] - final_output[j];
                    output_delta[j] = error * sigmoid_derivative(final_output[j]);
                }

                std::vector<double> hidden_delta(hidden_nodes);
                for (int j = 0; j < hidden_nodes; ++j) {
                    double error = 0.0;
                    for (int k = 0; k < output_nodes; ++k) {
                        error += output_delta[k] * W_out[j][k];
                    }
                    hidden_delta[j] = error * sigmoid_derivative(hidden_output[j]);
                }

                // Update weights and biases
                for (int j = 0; j < hidden_nodes; ++j) {
                    for (int k = 0; k < output_nodes; ++k) {
                        W_out[j][k] += learning_rate * hidden_output[j] * output_delta[k];
                    }
                }
                for (int j = 0; j < output_nodes; ++j) {
                    B_out[j] += learning_rate * output_delta[j];
                }
                for (int j = 0; j < input_nodes; ++j) {
                    for (int k = 0; k < hidden_nodes; ++k) {
                        W_in[j][k] += learning_rate * train_inputs[i][j] * hidden_delta[k];
                    }
                }
                for (int j = 0; j < hidden_nodes; ++j) {
                    B_hidden[j] += learning_rate * hidden_delta[j];
                }
            }

            if (epoch % 100 == 0) {
                std::cout << "Epoch " << epoch << ", Learning rate: " << learning_rate << ", Total error: " << total_loss << std::endl;
            }
        }
    }

    std::vector<double> predict(const std::vector<double>& input) {
        // Forward propagation for prediction
        std::vector<double> hidden_input(hidden_nodes, 0.0);
        for (int j = 0; j < hidden_nodes; ++j) {
            for (int k = 0; k < input_nodes; ++k) {
                hidden_input[j] += input[k] * W_in[k][j];
            }
            hidden_input[j] += B_hidden[j];
        }
        std::vector<double> hidden_output(hidden_nodes);
        for (int j = 0; j < hidden_nodes; ++j) {
            hidden_output[j] = sigmoid(hidden_input[j]);
        }

        std::vector<double> output_input(output_nodes, 0.0);
        for (int j = 0; j < output_nodes; ++j) {
            for (int k = 0; k < hidden_nodes; ++k) {
                output_input[j] += hidden_output[k] * W_out[k][j];
            }
            output_input[j] += B_out[j];
        }
        std::vector<double> final_output(output_nodes);
        for (int j = 0; j < output_nodes; ++j) {
            final_output[j] = sigmoid(output_input[j]);
        }
        return final_output;
    }

    // Methods for getting network parameters
    const std::vector<std::vector<double>>& get_W_in() const { return W_in; }
    const std::vector<double>& get_B_hidden() const { return B_hidden; }
    const std::vector<std::vector<double>>& get_W_out() const { return W_out; }
    const std::vector<double>& get_B_out() const { return B_out; }

private:
    int input_nodes;
    int hidden_nodes;
    int output_nodes;
    std::vector<std::vector<double>> W_in;
    std::vector<double> B_hidden;
    std::vector<std::vector<double>> W_out;
    std::vector<double> B_out;
};

// The ExampleWindow class demonstrating Gtk::DrawingArea, a custom status bar
class ExampleWindow : public Gtk::ApplicationWindow
{
public:
    ExampleWindow();
    ~ExampleWindow() override;

protected:
    void on_drawing_area_draw(const Cairo::RefPtr<Cairo::Context>& cr, int width, int height);
    void on_drawing_area_button_pressed(int n_press, double x, double y);
    void on_drawing_area_button_released(int n_press, double x, double y);
    void on_drawing_area_motion(double x, double y);
    void on_train_button_clicked();

private:
    //  Adds virtual points (midpoints) between every two adjacent points in a sequence
    std::deque<Point2D> add_midpoints(const std::deque<Point2D>& points) {
        if (points.size() < 2) {
            return points;
        }

        std::deque<Point2D> new_points;
        new_points.push_back(points.front());
        for (size_t i = 0; i < points.size() - 1; ++i) {
            Point2D midpoint = {
                (points[i].x + points[i+1].x) / 2.0,
                (points[i].y + points[i+1].y) / 2.0
            };
            new_points.push_back(midpoint);
            new_points.push_back(points[i+1]);
        }
        return new_points;
    }

    // Helper function for data normalization
    std::vector<double> normalize_data(const std::deque<Point2D>& points) {
        std::vector<double> normalized_data;
        if (points.size() < 2) return normalized_data;

        // Find the min/max of x and y coordinates
        double min_x = points[0].x, max_x = points[0].x;
        double min_y = points[0].y, max_y = points[0].y;
        for (const auto& p : points) {
            min_x = std::min(min_x, p.x);
            max_x = std::max(max_x, p.x);
            min_y = std::min(min_y, p.y);
            max_y = std::max(max_y, p.y);
        }

        // Calculate the range and take the larger of the two to preserve aspect ratio
        double range_x = max_x - min_x;
        double range_y = max_y - min_y;
        double max_range = std::max(range_x, range_y);

        // Protection against division by zero and zero range
        if (max_range < 1e-6) {
            max_range = 1.0;
        }

        // Resample to 12 points and normalize.
        // This results in 24 inputs for the neural network (12 x and 12 y).
        size_t sample_size = 12;
        double step = static_cast<double>(points.size() - 1) / (sample_size - 1);

        for (size_t i = 0; i < sample_size; ++i) {
            size_t index = static_cast<size_t>(i * step);
            if (index >= points.size()) index = points.size() - 1;

            // Center the gesture and normalize using the larger range to maintain aspect ratio.
            double normalized_x = (points[index].x - min_x) / max_range;
            double normalized_y = (points[index].y - min_y) / max_range;
            normalized_data.push_back(normalized_x);
            normalized_data.push_back(normalized_y);
        }

        return normalized_data;
    }

    void update_status_message();
    void start_training_session();
    void run_classification(bool is_held_gesture);
    void print_network_parameters() const;
    // Callback for the inactivity timer
    bool on_idle_timeout();

    Gtk::Box m_main_vbox;
    Gtk::DrawingArea m_drawing_area;
    Gtk::Box m_custom_statusbar_hbox;
    Gtk::Label m_status_message_label;
    Gtk::Box m_control_hbox;
    Gtk::Button m_train_button;

    // --- Gesture drawing state variables ---
    Point2D m_current_start_point;
    bool m_drawing_in_progress = false;
    std::deque<Point2D> m_mouse_trail;
    size_t MAX_TRAIL_SIZE = 100;

    // Variable for measuring mouse press time
    std::chrono::time_point<std::chrono::high_resolution_clock> m_press_start_time;
    // Variable for tracking the time of the last motion detection
    std::chrono::time_point<std::chrono::high_resolution_clock> m_last_motion_time;
    const long HOLD_THRESHOLD_MS = 250; // 0.25 seconds in milliseconds

    // --- Variable for the base status message ---
    Glib::ustring m_base_status_message;

    // --- Neural network instance ---
    std::unique_ptr<NeuralNetwork> m_nn;

    // --- Interactive training variables ---
    std::vector<std::string> m_labels = {"Drag Up (cmdRepeatCmd/cmdProperties)", "Drag Down (cmdPick)", "Drag Left (cmdUndo/cmdDelete)", "Drag Right (cmdOption/cmdLine)", "Drag Shape O (cmdCircle)", "Drag Shape 1 (cmdMove)", "Drag Shape N (cmdNew)", "Drag Shape J (cmdOK)", "Drag Shape ^ (cmdArc)", "Drag Shape > (cmdDim)", "Drag Shape < (cmdTrim)", "Drag Shape Z (cmdZoom/cmdZoomAll)", "Drag Shape S (cmdAddSymbol/cmdSave)", "Drag Shape 3 (cmdOpen)", "Drag Shape E (cmdEdit)", "Drag Shape L (cmdLtrim)", "Drag Shape V (cmdRotate", "Drag Shape b (cmdMirror)", "Drag Shape W (cmdHatch)", "Drag Shape T (cmdText)", "Drag Shape U", "Drag Shape M", "Drag Shape B", "Drag Shape 6", "Drag Shape 8", "Drag Shape 9"};
    std::map<std::string, std::vector<std::vector<double>>> m_training_data;
    int m_current_label_index = 0;
    int m_num_training_gestures = 0;
    const int GESTURES_PER_LABEL = 10;

    // variable added for state tracking
    bool m_in_training_mode = false;

    // To hold the connection to the timeout signal
    sigc::connection m_timeout_connection;
};

ExampleWindow::ExampleWindow()
    : m_train_button("Train")
{
    set_title("AI Gesture Demo try draw marks: Up, Down, Left, Right, Circle, 1, N, J, ^, >, <, Z, S, 3, E, L, V, d, W, T, U, M, B, 6, 8, 9");
    set_default_size(900, 700);

    m_main_vbox.set_orientation(Gtk::Orientation::VERTICAL);
    set_child(m_main_vbox);

    m_drawing_area.set_expand();
    m_drawing_area.set_draw_func(sigc::mem_fun(*this, &ExampleWindow::on_drawing_area_draw));
    m_main_vbox.append(m_drawing_area);

    auto click_gesture = Gtk::GestureClick::create();
    click_gesture->set_button(0);
    click_gesture->signal_pressed().connect(
        sigc::mem_fun(*this, &ExampleWindow::on_drawing_area_button_pressed));
    click_gesture->signal_released().connect(
        sigc::mem_fun(*this, &ExampleWindow::on_drawing_area_button_released));
    m_drawing_area.add_controller(click_gesture);

    auto motion_controller = Gtk::EventControllerMotion::create();
    motion_controller->signal_motion().connect(
        sigc::mem_fun(*this, &ExampleWindow::on_drawing_area_motion));
    m_drawing_area.add_controller(motion_controller);

    // --- Control setup ---
    m_control_hbox.set_orientation(Gtk::Orientation::HORIZONTAL);
    m_control_hbox.set_margin(5);
    m_control_hbox.set_spacing(5);

    m_train_button.set_halign(Gtk::Align::CENTER);
    m_train_button.set_hexpand();
    m_train_button.signal_clicked().connect(
        sigc::mem_fun(*this, &ExampleWindow::on_train_button_clicked));
    m_control_hbox.append(m_train_button);

    m_main_vbox.append(m_control_hbox);

     // --- Custom status bar setup ---
    m_custom_statusbar_hbox.set_orientation(Gtk::Orientation::HORIZONTAL);
    m_custom_statusbar_hbox.set_margin_top(5);
    m_custom_statusbar_hbox.set_margin_bottom(5);
    m_custom_statusbar_hbox.set_margin_start(10);
    m_custom_statusbar_hbox.set_margin_end(10);
    m_custom_statusbar_hbox.set_spacing(10);
    m_custom_statusbar_hbox.set_css_classes({"custom-statusbar"});

    m_status_message_label.set_hexpand();
    m_status_message_label.set_halign(Gtk::Align::START);
    m_status_message_label.set_label("Draw a gesture for classification.");
    m_custom_statusbar_hbox.append(m_status_message_label);

    m_main_vbox.append(m_custom_statusbar_hbox);

    auto css_provider = Gtk::CssProvider::create();
    css_provider->load_from_data(R"(
        .custom-statusbar {
            background-color: #e0e0e0;
            border-top: 1px solid #c0c0c0;
        }
    )");
    Gtk::StyleContext::add_provider_for_display(get_display(), css_provider, GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);

    // Inicialize AI with pretrained params
    m_nn = std::make_unique<NeuralNetwork>(24, 8, m_labels.size(), W_in_pretrained, B_hidden_pretrained, W_out_pretrained, B_out_pretrained);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_drawing_area_draw(const Cairo::RefPtr<Cairo::Context>& cr, int width, int height)
{
    cr->set_source_rgb(1.0, 1.0, 1.0);
    cr->paint();

    cr->set_source_rgb(0.1, 0.1, 0.1);
    cr->select_font_face("Sans", Cairo::ToyFontFace::Slant::NORMAL, Cairo::ToyFontFace::Weight::NORMAL);
    cr->set_font_size(24.0);

    Glib::ustring text_instruction = "Drawing Area: Press the mouse to start a gesture.";
    Cairo::TextExtents extents;
    cr->get_text_extents(text_instruction, extents);
    double text_x = (width - extents.width) / 2.0;
    double text_y = (height/10.0 - extents.height) / 2.0 + extents.height;
    cr->move_to(text_x, text_y);
    cr->show_text(text_instruction);

    cr->save();
    cr->translate(width / 2.0, height / 2.0);
    cr->scale(1.0, -1.0);

    cr->set_source_rgb(0.0, 0.0, 0.0);
    cr->set_line_width(2.0);

    // Drawing the mouse trail
    if (m_mouse_trail.size() > 1) {
        cr->move_to(m_mouse_trail[0].x, m_mouse_trail[0].y);
        for (size_t i = 1; i < m_mouse_trail.size(); ++i) {
            cr->line_to(m_mouse_trail[i].x, m_mouse_trail[i].y);
        }
        cr->stroke();
    }

        if (m_in_training_mode) {
    if (!g_gestureData.empty() && m_current_label_index < g_gestureData.size()) {
        const Gesture& gestureToDraw = g_gestureData[m_current_label_index];
        const std::vector<Point>& points = gestureToDraw.points;

       if (points.size() > 1) {
            cr->set_source_rgb(1, 0, 0);
            cr->set_line_width( 2.0);

            cr->move_to(points[0].x, points[0].y);
            cr->arc(points[0].x, points[0].y, 2.0, 0.0, 2.0 * G_PI);

            for (size_t i = 1; i < points.size(); ++i) {
                cr->line_to(points[i].x, points[i].y);
            }

    if (points.size() >= 2) {
        double arrow_length = 10.0;
        double arrow_width = 5.0;

        Point p1 = points[points.size() - 2];
        Point p2 = points[points.size() - 1];

        double dx = p2.x - p1.x;
        double dy = p2.y - p1.y;

            if (dx == 0 && dy == 0) {
                if (points.size() >= 8) {
                         p2 = points[points.size() - 8];
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
     }
    }

        double length = sqrt(dx * dx + dy * dy);
        double nx = dx / length;
        double ny = dy / length;

        double arrow_p1x = p1.x + nx * arrow_length + ny * arrow_width;
        double arrow_p1y = p1.y + ny * arrow_length - nx * arrow_width;

        double arrow_p2x = p1.x + nx * arrow_length - ny * arrow_width;
        double arrow_p2y = p1.y + ny * arrow_length + nx * arrow_width;

        cr->move_to(arrow_p1x, arrow_p1y);
        cr->line_to(p1.x, p1.y);
        cr->line_to(arrow_p2x, arrow_p2y);
    }
            cr->stroke();
        }
    }
    }

    cr->restore();
}

void ExampleWindow::on_drawing_area_button_pressed(int /*n_press*/, double x, double y)
{
    // If a timeout is pending, cancel it when a new drawing starts
    if (m_timeout_connection) {
        m_timeout_connection.disconnect();
    }

    // We record the press time and last motion to have a clean start
    m_press_start_time = std::chrono::high_resolution_clock::now();
    m_last_motion_time = m_press_start_time;

    double center_x = m_drawing_area.get_width() / 2.0;
    double center_y = m_drawing_area.get_height() / 2.0;

    double transformed_x = x - center_x;
    double transformed_y = -(y - center_y);

    m_drawing_in_progress = true;
    m_mouse_trail.clear();
    m_mouse_trail.push_back({transformed_x, transformed_y});
    m_drawing_area.queue_draw();
}

void ExampleWindow::on_drawing_area_button_released(int /*n_press*/, double x, double y)
{
    if (!m_drawing_in_progress) return;

    double center_x = m_drawing_area.get_width() / 2.0;
    double center_y = m_drawing_area.get_height() / 2.0;

    double transformed_x = x - center_x;
    double transformed_y = -(y - center_y);
    m_mouse_trail.push_back({transformed_x, transformed_y});

    m_drawing_in_progress = false;

    // Ensuring a sufficient number of points for sampling to 12 points.
    // For sampling to 12 points, we need at least 2 points so the step isn't infinite.
    const size_t MIN_POINTS_FOR_ANALYSIS = 2;
    if (m_mouse_trail.size() < MIN_POINTS_FOR_ANALYSIS) {
        m_status_message_label.set_label("Error: Record more mouse movement for classification. You need at least 2 points.");
        return;
    }

    // Determine the duration of mouse inactivity
    auto press_end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(press_end_time - m_last_motion_time);
    bool is_held_gesture = (duration.count() >= HOLD_THRESHOLD_MS);

    if (m_in_training_mode) {
        // Training mode - data collection
        if (m_current_label_index < static_cast<int>(m_labels.size())) {
            // Using the add_midpoints function to enrich the data before normalization.
            std::deque<Point2D> enriched_trail = add_midpoints(m_mouse_trail);
            std::vector<double> normalized_data = normalize_data(enriched_trail);
            std::string current_label = m_labels[m_current_label_index];
            m_training_data[current_label].push_back(normalized_data);
            m_num_training_gestures++;
            std::cout << "Recorded " << m_num_training_gestures << "x gesture for '" << current_label << "'" << std::endl;

            if (m_num_training_gestures >= GESTURES_PER_LABEL) {
                m_num_training_gestures = 0;
                m_current_label_index++;
            }
                m_drawing_area.queue_draw();
        }
    } else {
        // Classification mode
        if (m_nn) {
            run_classification(is_held_gesture);
            // Start a one-shot timer to check for inactivity after 1 second
            m_timeout_connection = Glib::signal_timeout().connect(
                sigc::mem_fun(*this, &ExampleWindow::on_idle_timeout), 1000
            );
        }
    }
    update_status_message();
}

void ExampleWindow::on_drawing_area_motion(double x, double y)
{
    if (!m_drawing_in_progress) return;

    // We update the time of the last motion
    m_last_motion_time = std::chrono::high_resolution_clock::now();

    double center_x = m_drawing_area.get_width() / 2.0;
    double center_y = m_drawing_area.get_height() / 2.0;

    double transformed_x = x - center_x;
    double transformed_y = -(y - center_y);

    m_status_message_label.set_label("Drawing a gesture: (" + std::to_string(static_cast<int>(transformed_x)) + ", " + std::to_string(static_cast<int>(transformed_y)) + ")");

    m_mouse_trail.push_back({transformed_x, transformed_y});
    if (m_mouse_trail.size() > MAX_TRAIL_SIZE) {
        m_mouse_trail.pop_front();
    }
    m_drawing_area.queue_draw();
}

// This function is called by the one-shot timer after 1 second
bool ExampleWindow::on_idle_timeout() {
    m_mouse_trail.clear();
    m_drawing_area.queue_draw();
    m_status_message_label.set_label("Screen cleared due to inactivity.");
    // Return false to stop the timer.
    return false;
}

void ExampleWindow::on_train_button_clicked() {
    if (m_in_training_mode) {
        // Second state: We are in training mode, we want to start training.
        // Here, training is started after data collection
        if (m_current_label_index < static_cast<int>(m_labels.size())) {
            m_status_message_label.set_label("Insufficient data. Complete data collection for all gestures.");
        } else {
            start_training_session();
            m_in_training_mode = false; // After training, we return to classification mode.
            m_train_button.set_label("Train");
        }
    } else {
        // First state: We are in classification mode, we want to start training.
        // This resets the network to random parameters and starts data collection.
        m_in_training_mode = true;
        // We reset the network, but this time to random parameters for retraining
        m_nn.reset(new NeuralNetwork(24, 8, m_labels.size()));
        m_current_label_index = 0;
        m_num_training_gestures = 0;
        m_training_data.clear();
        m_train_button.set_label("Start Training");

    }
    m_drawing_area.queue_draw();
    update_status_message();
}

void ExampleWindow::start_training_session() {
    std::cout << "Starting training..." << std::endl;
    m_train_button.set_sensitive(false);
    m_status_message_label.set_label("Training the neural network... please wait.");

    // Preparation of training data
    std::vector<std::vector<double>> train_inputs;
    std::vector<std::vector<double>> target_outputs;

    for (size_t i = 0; i < m_labels.size(); ++i) {
        std::string label = m_labels[i];
        std::vector<double> one_hot_vector(m_labels.size(), 0.0);
        one_hot_vector[i] = 1.0;

        for (const auto& gesture_data : m_training_data[label]) {
            train_inputs.push_back(gesture_data);
            target_outputs.push_back(one_hot_vector);
        }
    }

    // Creation and training of the network
    m_nn->train(train_inputs, target_outputs, 0.5, 5000);

    m_train_button.set_sensitive(true);
    update_status_message();
    std::cout << "Training complete! The network is ready for classification." << std::endl;
    print_network_parameters();
}

void ExampleWindow::print_network_parameters() const {
    if (!m_nn) return;

    std::cout << "\n// Generated neural network parameters for copy-pasting" << std::endl;
    std::cout << "std::vector<std::vector<double>> W_in_pretrained = {" << std::endl;
    for (size_t i = 0; i < m_nn->get_W_in().size(); ++i) {
        std::cout << "    { ";
        for (size_t j = 0; j < m_nn->get_W_in()[i].size(); ++j) {
            std::cout << std::fixed << std::setprecision(6) << m_nn->get_W_in()[i][j];
            if (j < m_nn->get_W_in()[i].size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << " },";
        if (i < m_nn->get_W_in().size() - 1) {
            std::cout << std::endl;
        }
    }
    std::cout << "\n};" << std::endl;

    std::cout << "std::vector<double> B_hidden_pretrained = { ";
    for (size_t i = 0; i < m_nn->get_B_hidden().size(); ++i) {
        std::cout << std::fixed << std::setprecision(6) << m_nn->get_B_hidden()[i];
        if (i < m_nn->get_B_hidden().size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << " };" << std::endl;

    std::cout << "std::vector<std::vector<double>> W_out_pretrained = {" << std::endl;
    for (size_t i = 0; i < m_nn->get_W_out().size(); ++i) {
        std::cout << "    { ";
        for (size_t j = 0; j < m_nn->get_W_out()[i].size(); ++j) {
            std::cout << std::fixed << std::setprecision(6) << m_nn->get_W_out()[i][j];
            if (j < m_nn->get_W_out()[i].size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << " },";
        if (i < m_nn->get_W_out().size() - 1) {
            std::cout << std::endl;
        }
    }
    std::cout << "\n};" << std::endl;

    std::cout << "std::vector<double> B_out_pretrained = { ";
    for (size_t i = 0; i < m_nn->get_B_out().size(); ++i) {
        std::cout << std::fixed << std::setprecision(6) << m_nn->get_B_out()[i];
        if (i < m_nn->get_B_out().size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << " };" << std::endl;
    std::cout << "\n// End of generated parameters" << std::endl;
}

void ExampleWindow::run_classification(bool is_held_gesture) {
    // Using the add_midpoints function to enrich the data before normalization.
    std::deque<Point2D> enriched_trail = add_midpoints(m_mouse_trail);
    std::vector<double> normalized_data = normalize_data(enriched_trail);
    if (normalized_data.empty()) {
        m_status_message_label.set_label("Classification error: Insufficient gesture data.");
        return;
    }
    std::vector<double> prediction = m_nn->predict(normalized_data);

    int predicted_class = 0;
    double max_value = prediction[0];
    for (size_t i = 1; i < prediction.size(); ++i) {
        if (prediction[i] > max_value) {
            max_value = prediction[i];
            predicted_class = i;
        }
    }

    std::string classified_label = (predicted_class < m_labels.size()) ? m_labels[predicted_class] : "Unknown";
    std::string held_status = is_held_gesture ? " (with endhold)" : " (without endhold)";
    m_base_status_message = "Classification: " + classified_label + held_status + " (confidence: " + std::to_string(max_value) + ")";
    m_status_message_label.set_label(m_base_status_message);

    std::cout << "Classification: " << classified_label << held_status << " with value: " << max_value << std::endl;
}

void ExampleWindow::update_status_message() {
    if (m_in_training_mode) {
        if (m_current_label_index >= static_cast<int>(m_labels.size())) {
            m_status_message_label.set_label("Data collection complete. Press 'Start Training' to train AI network.");
            m_train_button.set_sensitive(true);

        } else {
            std::string message = "Gesture training '" + m_labels[m_current_label_index] + "': " + std::to_string(m_num_training_gestures) + "/" + std::to_string(GESTURES_PER_LABEL);
            m_status_message_label.set_label(message);
        }
    } else {
        m_status_message_label.set_label(m_base_status_message);
    }
}
int main(int argc, char* argv[])
{
    auto app = Gtk::Application::create("org.gtkmm.examples.drawingarea");
    return app->make_window_and_run<ExampleWindow>(argc, argv);
}

